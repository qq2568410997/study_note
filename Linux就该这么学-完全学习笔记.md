### 第二课
1. 软件安装
	+ 在红帽中安装软件，最开始是使用的是源码包方式
		1. 难度极大
		2. 各种依赖自行处理
	+ 自从rpm出来(redHat package manageer 红帽包管理器)
		1. 简化软件安装的流程
			+ 根据规则安装源码包
		2. yum仓库(解决源码包安装时的各种依赖关系)
			+ 根据依赖关系流程(一张规则表)
			+ 利用rpm依次安装所需依赖包
2. 红帽5/6系统和7系统最大的区别
	+ 红帽7变化大
		1. 5/6系统启动时的初始化使用的是init
		2. 7系统启动时初始化使用的是systemd
			+ systemd不仅仅接管了原先init的要做的事
			+ 还管理着很多服务，所以之前在5/6中使用的一些服务命令都不能在7中使用了，需要通过systemd进行操作(典型一直用到的命令如下)
				1. systemctl start   服务名称    启动服务
				2. systemctl restart 服务名称    重启服务
				3. systemctl stop    服务名称    停止服务
				4. systemctl status  服务名称    查看服务状态
				5. systemctl enable  服务名称    允许开机启动
				6. systemctl disable 服务名称    禁止开机启动
3. 人与硬件交互
	+ 内核直接操作硬件
	+ 内核提供了API接口方便人去操作硬件
	+ 人(开发者)利用API写shell脚本去间接操作硬件(脚本是API的集合)
		1. 简单理解---一个API实现一个功能(其实一个功能的实现远不止一个API就可以完成的)
		2. 那么API的集合表示API不止一个，意味着一个脚本可以实现很多个功能
	+ 人(开发者)将脚本提供给人(使用者)
	+ 使用者只需要运行脚本就可以间接与硬件交互，从而实现某种功能
	+ PS:  红帽系统给我们提供好的shell脚本有很多，这里我们主要使用bash(可以完成多项功能的Linux命令的集合)

4. Linux命令
	+ 实现某项功能的API，被称为是Linux命令
	+ 执行形式: 命令+[参数]+对象(以空格分隔，这里的[+]仅仅表示的是一种关系)
		1. 参数是对该命令的修饰，简单说就是原始的: 命令+对象=输出信息-->无法满足我们的需求，此时就可以进行一些处理，得到我们想要的(参数就是为了满足需求而诞生的)
		2. 参数一般来说分为
			+ 短格式: 一个字母，如: -a        一般是单个短线
			+ 长格式: 一个单词: 如: --aaa     一般是双个短线
		3. 参数合并基本原则
			+ 短对短
			+ 长对长
5. 常用的Linux命令(严格区分大小写)
	+ echo
		1. 直接输出字符串         echo Linux
		2. 输出变量              echo $SHELL  输出当前使用的shell交互脚本的名称
	+ date(比较特殊)
		1. 输出年月日  date '+%Y-%m-%d %H:%M:%S'
	+ reboot 重启
	+ poweroff 关机
	+ ps (process status查看进程状态)-----静态的，显示的是当前执行时的进程信息列表
		1. ps      查看当前用户进程
		2. ps -aux 查看所有进程的详情信息(-aux是短格式的合并)
			+ -a  全部
			+ -u  用户详情信息
			+ -x  非用户控制的终端进程(即系统进程)
	+ top(与ps类似，但是是动态显示的，即实时显示进程信息列表的变化----类似windows的任务管理器面板)
	+ uptime  显示top命令展示的详情的第一行数据
	+ pidof 服务名称   ---查看服务的PID
	+ kill PID/服务名称---杀死PID对应的服务
	+ killall 服务名称 ---如果一个服务，不止一个进程，可以使用该命令杀死
	+ kill -9 PID/服务名称     ---强制杀死一个服务
	+ ifconfig                ---查看网卡信息
		1. 网卡名称    开头的标题
		2. inet       IP地址
		3. ether      MAC地址
		4. RX         收到的数据大小
		5. TX         发送出去的数据大小
	+ uname  查看系统内核以及版本等信息
		1. -a  查看系统内核以及版本的详细信息
	+ cat 查看信息
	+ man 查看该Linux命令的帮助手册
		1. man ls
	+ who(W)   显示当前开启的终端
	+ free  查看内存
		1. -m  以M为单位显示
		2. -g  以G为单位显示
	+ last 查看登入记录(黑客是可以修改日志的，所以不准确)
	+ history 查看历史输入的命令
		1. 使用 !58 表示执行序号为58的那个Linux命令
	+ sosreport 救援报告(就是收集一些信息打包成一个report，然后发送给别人)
	+ pwd  当前所在目录
	+ cd   切换目录
		1. [-]  上一次目录
		2. ~    根目录
		3. ..   上一级目录
	+ ls   查看当前目录下的文件
		-al 全部的文件的详情信息
		
	+ cat  查看小文件(当面命令行屏幕无法显示完毕，然后一直闪烁显示的就属于大文件)
	+ more 查看大文件(可以控制分页显示)
	+ head 查看文件开头
		1. -n 5 xxx  查看xxx文件的前5行
	+ tail 查看文件的结尾
		1. -n 5 xxx  查看xxx文件的最后5行
		2. -f xxx    实时显示xxx文件的信息
	+ tr 用于文本的替换(text replace)
		1. 用法: tr [原始字符] [目标字符]  --- 将text中出现的原始字符替换为目标字符
	+ wc  统计文本的行数、字数、单词数 
		1. -l  行数
		2. -w  单词数(字数)
		3. -c  计数(字节为单位)
	+ stat 查看文件的存储信息和修改时间等信息
		1. Access  表示的是最后一次打开的时间
		2. Modify  表示的是最后一次修改文件内容的时间
		3. Change  表示的是最后一个修改非文件内容(诸如名称等属性)的时间
	+ cut 表示截取符合条件的文本
		1. -d :    ----设置间隔符(这里是冒号)
		2. -f[num] ----设置第几列
		3. cut -d: -f1 xxx   表示的是截取以:冒号分隔后的第一列数据
	+ diff 查看两个文件之间的不同
		1. --brief  表示的是显示两个文件比较后的简洁信息
		2. -c       表示的是显示比较后的全部详情
	+ touch  创建一个空白的文件或者设置文件的各种时间
		1. -a   修改访问时间
		2. -m   修改更改时间
		3. -d   同时修改访问和更改时间
	+ mkdir  创建一个目录
		1. -p  表示的是强制创建一个层级不存在的目录(将涉及到的层级都创建)
	+ cp  复制 
		1. cp 原文件 副本文件
	+ mv  剪切
		1. mv 原文件路径  目标文件路径(同目录下剪切相当于是重命名)
	+ rm  删除(删除文件或者目录)
		1. -f  强制删除，不需要确认(文件)
		2. -rf 强制删除，不需要确认(目录)
	+ file 查看对象的属性(是文件or目录)
	+ tar  压缩解压文件
		1. czvf   压缩文件 (c表示的是创建)
			+ tar czvf 压缩文件的名称  压缩的源数据
		2. xzvf   解压文件 (x表示的是解压缩)
			+ tar xzvf 压缩文件的名称  解压后的文件名(不写默认是压缩文件的名称)
		3. cvf(xvf) 表示不知道压缩格式，可以直接这样写(让系统自动去判断)
	+ grep 对文本内容进行关键词的搜索匹配
		1. grep -n core xxx   表示的是在xxx文件中寻找core关键词，并显示其所在行
	+ find 全局查找
		1. find / -user xxx -exec cp -rf {} /home/d \;  
			+ -user xxx 表示的是全局搜索与xxx用户相关的文件目录
			+ -exec xxx \;  将寻找到的数据作xxx处理
			+ cp -rf {} /home/d  表示的是将搜索出来的文本文件/目录等复制到/home/d

	